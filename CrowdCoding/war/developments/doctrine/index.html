<html>
<head>
	<title>JSDoc Parsers</title>
	<style type="text/css">
		.ace_editor {
			min-height: 200px;
		}
	</style>
	<link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css"></link>
</head>
<body>
	<div class="container-fluid">
		<div class="row">
			<div class="col-md-6">
				<h4>Function Declaration</h4>
				<textarea id="funct">/**
 * this is the description of the function
 * @name functName
 * @param {number} firstPar - this is the first parameter
 * @param {string} secondPar - this is the second parameter
 * @param {custom} thirdPar - this is the third parameter
 * @returns {object}
*/</textarea>
 				<table id="parsedFunct"></table>
			</div>
			<div class="col-md-6">
				<h4>Data Type Declaration</h4>
				<textarea id="datatype">/**
 * this is the description of the datatype
 * @typedef {Object} datatypeName
 * @property {number} firstProp - this is the first prop
 * @property {boolean[]} secondProp - this is the second prop
 * @property {string} thirdProp - this is the third prop
*/</textarea>
 				<table id="parsedDatatype"></table>
			</div>
		</div>
	</div>
	


	<script type="text/javascript" src="http://code.jquery.com/jquery-1.11.3.min.js"></script>
	<script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
	<script src="/include/ace-editor/src/ace.js"> </script> 
	<script type="text/javascript" src="./bundle.js"></script>

	<script type="text/javascript">

		var functEditor = ace.edit('funct');
		functEditor.getSession().setMode("ace/mode/javascript");
		functEditor.setTheme("ace/theme/xcode");

		var datatype = ace.edit('datatype');
		datatype.getSession().setMode("ace/mode/javascript");
		datatype.setTheme("ace/theme/xcode");

		var changeTimeout = null;
		functEditor.on('change',function changeListener(value){
			if( changeTimeout !== undefined )
				clearTimeout(changeTimeout);

			changeTimeout = setTimeout(function(){
				var text   = functEditor.getValue();
				var parsed = parseFunctionDescription( text );
				var validationErrors = validateFunctionDescription( parsed );

				if ( validationErrors !== '' ) {
					console.error( validationErrors );
				}	
				else {
					var header = buildFunctionHeader( parsed );
					console.log(header);
					$('#parsedFunct').html( header );
				} 
			},200);
		});

		function parseFunctionDescription( text ){
			var parsed = doctrine.parse(text,{unwrap:true});
			var tags = parsed.tags;

			var functObj = {
				name: '',
				description: '',
				parameters: [],
				returnType: ''
			};

			functObj.description = parsed.description;

			tags.forEach(function(tag){
				switch (tag.title){
					case 'name': 
						functObj.name = tag.name
						break;

					case 'param':
						if ( tag.type.type === 'NameExpression' ) {
							functObj.parameters.push({
								name: tag.name,
								type: tag.type.name,
								description: tag.description
							});
						}
						else if ( tag.type.type === 'TypeApplication' ) {
							functObj.parameters.push({
								name: tag.name,
								type: tag.type.applications[0].name + '[]',
								description: tag.description
							});
						}
						break;

					case 'return':
						functObj.returnValue = tag.type.name
						break;

					default:
						break;
				}
			});

			return functObj;
		}

		function validateFunctionDescription( functObj ){
			var errors = [];

			if( functObj.name === '' )
				errors.push( 'You should provide a function name!');

			if( functObj.description === '' )
				errors.push( 'You should write a description!');

			if( functObj.parameters.length == 0 )
				errors.push( 'You should define at least one parameter!' );

			if( functObj.returnValue === '' )
				errors.push( 'You should define the return type!');

			return errors.join('\n');
		}

		function buildFunctionHeader( functObj ){

			var header = 'function ';

			header += functObj.name + '(' 
					+ functObj.parameters.map(function(par){
						return par.name;
					  })
					  .join(',')
					+ '){}';
			return header;
		}

		datatype.on('change',function changeListener(){
			if( changeTimeout !== undefined )
				clearTimeout(changeTimeout);

			changeTimeout = setTimeout(function(){
				var text   = datatype.getValue();
				var parsed = parseDatatype( text );
				var validationErrors = validateDatatype( parsed );

				if ( validationErrors !== '' ) {
					console.error( validationErrors );
				}	
				else {

					$('#parsedDatatype').html( buildDatatypeDesc(parsed) );
				} 
			});
		});

		function parseDatatype( text ){
			var parsed = doctrine.parse(text,{unwrap:true});
			var tags   = parsed.tags;
			var dataObj = {
				name: '',
				description: '',
				properties: []
			};

			dataObj.description = parsed.description;

			tags.forEach(function(tag){
				switch (tag.title){
					case 'typedef': 
						dataObj.name = tag.description
						break;

					case 'property':
						if ( tag.type.type === 'NameExpression' ) {
							dataObj.properties.push({
								name: tag.name,
								type: tag.type.name,
								description: tag.description
							});
						}
						else if ( tag.type.type === 'TypeApplication' ) {
							dataObj.properties.push({
								name: tag.name,
								type: tag.type.applications[0].name + '[]',
								description: tag.description
							});
						}
						break;

					default:
						break;
				}
			});

			return dataObj;
		}

		function validateDatatype( dataObj ){
			var errors = [];

			if( dataObj.name === '' )
				errors.push( 'You should provide a datatype name!');

			if( dataObj.description === '' )
				errors.push( 'You should write a description!');

			if( dataObj.properties.length == 0 )
				errors.push( 'You should define at least one property!' );

			return errors.join('\n');
		}

		function buildDatatypeDesc( dataObj ){
			return dataObj.name + ' { '
				 + dataObj.properties.map(function(prop){
				 	return prop.name + ':' + prop.type;
				   })
				   .join(',')
				 + '}';
		}
		
		
	</script>
</body>
</html>